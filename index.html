<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.8.0/css/bulma.min.css">
    <title>Sans Titre in 3D</title>
</head>
<body>

<section class="section">
    <div class="container">
    <h1 class="title">
        ThreeJS Water
    </h1>
    <p class="subtitle">
        This is an implementation of <a href="http://madebyevan.com/webgl-water">Evan Wallace's webgl-water demo</a> using <a href="http://threejs.org">ThreeJS</a>, made by <a href="https://twitter.com/martinRenou">Martin Renou</a>.
    </p>
    <p>Click and move mouse to disturb the water</p>
    <p>
        Based off of <a href="https://github.com/evanw/webgl-water">webgl-water</a> by <a href="https://twitter.com/evanw">Evan Wallace</a>
    </p>
    <div class="columns">
        <canvas id="canvas" height="600px" width="800px"></canvas>
    </div>

    </div>
</section>


<!-- This is just a smoothing 'compute shader' for using manually: -->
<script id="smoothFragmentShader" type="x-shader/x-fragment">

    uniform sampler2D smoothTexture;

    void main()	{

        vec2 cellSize = 1.0 / resolution.xy;

        vec2 uv = gl_FragCoord.xy * cellSize;

        // Computes the mean of texel and 4 neighbours
        vec4 textureValue = texture2D( smoothTexture, uv );
        textureValue += texture2D( smoothTexture, uv + vec2( 0.0, cellSize.y ) );
        textureValue += texture2D( smoothTexture, uv + vec2( 0.0, - cellSize.y ) );
        textureValue += texture2D( smoothTexture, uv + vec2( cellSize.x, 0.0 ) );
        textureValue += texture2D( smoothTexture, uv + vec2( - cellSize.x, 0.0 ) );

        textureValue /= 5.0;

        gl_FragColor = textureValue;

    }

</script>

<!-- This is a 'compute shader' to read the current level and normal of water at a point -->
<!-- It is used with a variable of size 1x1 -->
<script id="readWaterLevelFragmentShader" type="x-shader/x-fragment">

    uniform vec2 point1;

    uniform sampler2D levelTexture;

    // Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target

    float shift_right( float v, float amt ) {

        v = floor( v ) + 0.5;
        return floor( v / exp2( amt ) );

    }

    float shift_left( float v, float amt ) {

        return floor( v * exp2( amt ) + 0.5 );

    }

    float mask_last( float v, float bits ) {

        return mod( v, shift_left( 1.0, bits ) );

    }

    float extract_bits( float num, float from, float to ) {

        from = floor( from + 0.5 ); to = floor( to + 0.5 );
        return mask_last( shift_right( num, from ), to - from );

    }

    /* keep semicolons here */
    vec4 encode_float( float val ) {
        if (val == 0.0) return vec4(0, 0, 0, 0);
        float sign = val > 0.0 ? 0.0 : 1.0;
        val = abs(val);
        float exponent = floor(log2(val));
        float biased_exponent = exponent + 127.0;
        float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;
        float t = biased_exponent / 2.0;
        float last_bit_of_biased_exponent = fract(t) * 2.0;
        float remaining_bits_of_biased_exponent = floor(t);
        float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;
        float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;
        float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits( fraction, 16.0, 23.0 ) ) / 255.0;
        float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent ) / 255.0;
        return vec4(byte4, byte3, byte2, byte1 );
    }

    void main()	{
        vec2 cellSize = 1.0 / resolution.xy;
        float waterLevel = texture2D(levelTexture, point1).x;

        vec2 normal = vec2(
            ( texture2D( levelTexture, point1 + vec2( - cellSize.x, 0 ) ).x - texture2D( levelTexture, point1 + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
            ( texture2D( levelTexture, point1 + vec2( 0, - cellSize.y ) ).x - texture2D( levelTexture, point1 + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS );
        if ( gl_FragCoord.x < 1.5 ) {
            gl_FragColor = encode_float( waterLevel );
        } else if ( gl_FragCoord.x < 2.5 ) {
            gl_FragColor = encode_float( normal.x );
        } else if ( gl_FragCoord.x < 3.5 ) {
            gl_FragColor = encode_float( normal.y );
        } else {
            gl_FragColor = encode_float( 0.0 );
        }
    }
</script>


<script type="importmap">
    {
        "imports": {
            "three": "./node_three_files/build/three.module.js",
            "three/examples/jsm/": "./node_three_files/examples/jsm/"
        }
    }
</script>

<script type="module" src="index.js"></script>

</body>
</html>